use std::fs::File;
use std::io;
use std::io::Write;
use std::path::PathBuf;

use structopt::StructOpt;

use dla::{Dla, Vec3};

pub type Rgb = [f64; 3];

/// Simulate 3D diffusion limited aggregation (DLA for short) and save the final
/// system as a povray scene ready to be rendered.
#[derive(StructOpt, Debug)]
struct App {
    /// Number of particles to add to the DLA system.
    #[structopt(short = "p", long = "particles", default_value = "10000")]
    particles: usize,

    #[structopt(short = "a", long = "attraction-radius", default_value = "8")]
    attraction_radius: u16,

    #[structopt(short = "s", long = "spawn-offset", default_value = "10")]
    spawn_offset: u32,

    #[structopt(short = "t", long = "scene-type")]
    scene_type: SceneType,

    /// Output filename where to save the povray scene.
    #[structopt(parse(from_os_str), default_value = "dla.pov")]
    output: PathBuf,
}

#[derive(Debug)]
enum SceneType {
    Povray,
    Js,
}

impl std::str::FromStr for SceneType {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "povray" => Ok(SceneType::Povray),
            "javascript" | "js" => Ok(SceneType::Js),
            s => Err(format!("`{}` is not a valid scene type", s)),
        }
    }
}

fn main() -> io::Result<()> {
    let args = App::from_args();

    let seeds = vec![Vec3::new(0, 0, 0)];

    // cross
    // for i in 1..=100 {
    //     seeds.extend_from_slice(&[
    //         Vec3::new(i, 0, 0),
    //         Vec3::new(0, i, 0),
    //         Vec3::new(0, 0, i),
    //         Vec3::new(-i, 0, 0),
    //         Vec3::new(0, -i, 0),
    //         Vec3::new(0, 0, -i),
    //     ]);
    // }

    let mut dla = Dla::new(args.spawn_offset, args.attraction_radius, seeds).unwrap();

    let mut rng = rand::thread_rng();
    for _ in 0..args.particles {
        dla.add(&mut rng);
    }

    match args.scene_type {
        SceneType::Povray => write_povray(args.output, &dla),
        SceneType::Js => write_js(args.output, &dla),
    }
}

pub fn write_povray(path: PathBuf, dla: &Dla) -> io::Result<()> {
    let path = path.with_extension("pov");
    let mut out = File::create(&path)?;

    let scene_bbox = dla.bbox();
    let away_dist = (scene_bbox.lower() - scene_bbox.center()).norm();
    let camera_pos = Vec3::new(0, 0, scene_bbox.lower().z - away_dist);

    #[rustfmt::skip]
    writeln!(
        out,
        r#"
#version 3.7;

#include "colors.inc"

global_settings {{ assumed_gamma 1.0 }}
#default{{ finish {{ ambient 0.1 diffuse 0.9 }} }}

background {{ color Black }}

// scene bbox <{}, {}, {}> <{}, {}, {}>

camera {{
  location <{}, {}, {}>
  look_at <0, 0, 0>
}}
"#,
        scene_bbox.lower().x, scene_bbox.lower().y, scene_bbox.lower().z,
        scene_bbox.upper().x, scene_bbox.upper().y, scene_bbox.upper().z,
        camera_pos.x, camera_pos.y, camera_pos.z,
    )?;

    let mut add_light = |pt: Vec3, intensity| {
        let light = pt + (pt - scene_bbox.center()).normalized() * away_dist;

        #[rustfmt::skip]
        let r = writeln!(
            out,
            "light_source {{ <{}, {}, {}> color rgb <{}, {}, {}> }}",
            light.x, light.y, light.z,
            intensity, intensity, intensity
        );
        r
    };

    // key light
    add_light(Vec3::new(scene_bbox.lower().x, scene_bbox.center().y, scene_bbox.lower().z), 1.0)?;

    // fill light
    add_light(Vec3::new(scene_bbox.upper().x, scene_bbox.lower().y, scene_bbox.lower().z), 0.75)?;

    // background light
    add_light(Vec3::new(scene_bbox.lower().x, scene_bbox.upper().y, scene_bbox.upper().z), 0.5)?;

    // bottom light
    add_light(Vec3::new(scene_bbox.center().x, scene_bbox.lower().y, scene_bbox.center().z), 0.75)?;

    // top light
    add_light(Vec3::new(scene_bbox.center().x, scene_bbox.upper().y, scene_bbox.center().z), 0.5)?;

    writeln!(out, "\nunion {{")?;
    for p in dla.cells() {
        writeln!(out, "  sphere {{ <{}, {}, {}>, 1 }}", p.x, p.y, p.z)?;
    }

    writeln!(
        out,
        r#"  texture {{
    pigment {{ color rgb<0.1, 0.3, 0.1> }}
    finish {{ phong 0.5 }}
  }}
}}"#
    )?;

    println!(
        r#"The DLA system was correctly generated. It contains {} particles.

The final state of the system has been saved as a PovRay scene (dla.pov) which
is possible to render with a povray invocation like the following

`povray +A +W1600 +H1200 {}`
"#,
        dla.len(),
        path.display()
    );

    Ok(())
}

pub fn write_js(path: PathBuf, dla: &Dla) -> io::Result<()> {
    let path = path.with_extension("js");
    let mut out = File::create(&path)?;

    let scene_bbox = dla.bbox();

    #[rustfmt::skip]
    writeln!(
        out,
        r#"// 3D DLA geometry - generated by github.com/d-dorazio/dla

var DLA = {{
    bbox: {{
        lower: {{ x: {}, y: {}, z: {} }},
        upper: {{ x: {}, y: {}, z: {} }},
    }},
    particles: ["#,
        scene_bbox.lower().x, scene_bbox.lower().y, scene_bbox.lower().z,
        scene_bbox.upper().x, scene_bbox.upper().y, scene_bbox.upper().z,
    )?;

    for p in dla.cells() {
        writeln!(out, "        {{ x: {}, y: {}, z: {} }},", p.x, p.y, p.z)?;
    }

    writeln!(
        out,
        r#"    ],
}}"#
    )?;

    Ok(())
}

// pub fn lerp_rgb(a: Rgb, b: Rgb, t: f64) -> Rgb {
//     [
//         a[0] + (b[0] - a[0]) * t,
//         a[1] + (b[1] - a[1]) * t,
//         a[2] + (b[2] - a[2]) * t,
//     ]
// }
